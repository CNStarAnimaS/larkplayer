{"version":3,"sources":["../../js/utils/merge-options.js"],"names":["mergeOptions","result","args","forEach","opt","value","key"],"mappings":";;;;;kBAgBwBA,Y;;AAVxB;;AAEA;;;;;;;;AAQe,SAASA,YAAT,GAA+B;AAC1C,QAAIC,SAAS,EAAb;;AAD0C,sCAANC,IAAM;AAANA,YAAM;AAAA;;AAG1CA,SAAKC,OAAL,CAAa,eAAO;AAChB;AACA;AACA,YAAI,CAACC,GAAL,EAAU;AACN;AACH;;AAED,uBAAKA,GAAL,EAAU,UAACC,KAAD,EAAQC,GAAR,EAAgB;AACtB;AACA,gBAAI,CAAC,kBAAQD,KAAR,CAAL,EAAqB;AACjBJ,uBAAOK,GAAP,IAAcD,KAAd;AACH,aAFD,MAEO;AACH;AACA,oBAAI,CAAC,kBAAQJ,OAAOK,GAAP,CAAR,CAAL,EAA2B;AACvBL,2BAAOK,GAAP,IAAc,EAAd;AACH;;AAED;AACAL,uBAAOK,GAAP,IAAcN,aAAaC,OAAOK,GAAP,CAAb,EAA0BD,KAA1B,CAAd;AACH;AACJ,SAbD;AAcH,KArBD;;AAuBA,WAAOJ,MAAP;AACH,C,CA3CD","file":"merge-options.js","sourcesContent":["/**\n * @file 深拷贝和合并对象（为 options 定制）\n * @author yuhui06@baidu.com\n * @date 2017/11/3\n */\n\nimport {isPlain, each} from './obj.js';\n\n/**\n * 深拷贝和合并对象，为 options 定制\n *\n * @param {...Object} args 要合并的对象\n * @return {Object} 合并后的对象\n * @desc\n *      1) 这里其实我们还有一个隐形的约定：options 不要乱传，options 本身是个对象，options 的值要么是对象，要么是普通类型（非引用）\n */\nexport default function mergeOptions(...args) {\n    let result = {};\n\n    args.forEach(opt => {\n        // 对空数组 forEach 时，回调函数传入的参数会是 undefined\n        // 这个判断，就是这个函数的鲁棒性所在\n        if (!opt) {\n            return;\n        }\n\n        each(opt, (value, key) => {\n            // 不是对象时，我们认为他只是普通类型（非引用）时，直接赋值就行了\n            if (!isPlain(value)) {\n                result[key] = value;\n            } else {\n                // 如果 value 是对象，先保证 result[key] 是对象，再进行后面的赋值\n                if (!isPlain(result[key])) {\n                    result[key] = {};\n                }\n\n                // 把剩下的值 merge 到 result[key] 上，如果剩下的值的 key 里还有对象，就递归了\n                result[key] = mergeOptions(result[key], value);\n            }\n        });\n    });\n\n    return result;\n}"]}